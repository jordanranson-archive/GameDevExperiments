<!DOCTYPE html>
<html>
<script>
	var canvas;
	var ctx;
	var maze;
	var mazeW; var mazeH; var field; var frontier;

	window.onload = function() {
		canvas = document.getElementById("canvas");
		ctx = canvas.getContext('2d');

		//fill bg
		ctx.fillStyle = "rgb(158,153,94)";
		ctx.fillRect(0,0,800,600);

		maze = createMaze(0,0,40,40);
		drawMaze(ctx,maze,0,0);
	};

	//create a maze based off python growing tree algorithm at http://pcg.wdfiles.com/local--files/pcg-algorithm:maze/growingtree.py
	//returns field, an array of said size
	function createMaze( x, y, rows, cols ) {
		//the grid of the maze
		// # is wall  . is empty space  , is exposed but undertemined  ? is unexposed and undertermined
		field = new Array();
		mazeH = rows;
		mazeW = cols;
		
		//populate grid with ?'s
		for(var i=0; i<rows;i++){
			var row = new Array();
			for(var ii=0; ii<cols; ii++){
					row.push('?');
			}
			field.push(row);
		}
		
		
		//list of coordinates of exposed but undetermined cells
		frontier = new Array();
		
		//choose random starting point
		var xchoice = Math.floor(Math.random()*cols);
		var ychoice = Math.floor(Math.random()*rows);
		
		carve(new Array(ychoice, xchoice));
		
		//parameter branchrate:
		//zero is unbiased, positive will make branches more frequent, negative will cause long passages
	    //this controls the position in the list chosen: positive makes the start of the list more likely,
	    //negative makes the end of the list more likely
	    //large negative values make the original point obvious
	    //try values between -10, 10 
		var branchrate = 5;
		
		
		while(frontier.length > 0){
			var pos = Math.random();
			pos = Math.pow(pos,Math.pow(Math.E,-branchrate));
			var rpos = Math.floor(pos * frontier.length);
			var choice = frontier[rpos];
			if (check(choice)){
				carve(choice); // carve the path
			}
			else {
				harden(choice);
			}
			frontier.splice(rpos,1);
		}
		
		for(var iy=0; iy<rows; iy++){
			for(var ix=y; ix<cols; ix++){
				if(field[y][x] == '?'){ field[y][x] = '#'; }
			}
		} 
		
		
		//Done return it
		return field;
	}

	function check( posi ) {
	    var y = posi[0]; var x = posi[1];
		var nodiagonals = true; //make the default to check for diagonals 
		if(posi[2]){ nodiagonals = posi[2]; }

		var edgestate = 0;
	    if (x > 0) {
	        if (field[y][x-1] == '.'){
	            edgestate += 1 ;
			}
		}
	    if (x < mazeW-1){
	        if (field[y][x+1] == '.'){
	            edgestate += 2;
			}
		}
	    if (y > 0){
	        if (field[y-1][x] == '.'){
	            edgestate += 4;
			}
		}
	    if (y < mazeH-1){
	        if (field[y+1][x] == '.'){
	            edgestate += 8 ;
			}
		}
		
		if(nodiagonals){
			if (edgestate == 1){
	            if (x < mazeW-1){
	                if (y > 0){
	                    if (field[y-1][x+1] == '.'){
	                        return 0;
						}
					}
	                if (y < mazeH-1){
	                    if (field[y+1][x+1] == '.'){
	                        return 0;
						}
					}
	            return 1;
				}
			}
	        else if ( edgestate == 2){
	            if (x > 0){
	                if (y > 0){
	                    if (field[y-1][x-1] == '.'){
	                        return 0;
						}
					}
	                if (y < mazeH-1){
	                    if (field[y+1][x-1] == '.'){
	                        return 0;
						}
					}
	            return 1;
				}
			}
	        else if ( edgestate == 4){
	            if (y < mazeH-1){
	                if (x > 0){
	                    if (field[y+1][x-1] == '.'){
	                        return 0;
						}
					}
	                if (x < mazeW-1){
	                    if (field[y+1][x+1] == '.'){
	                        return 0;
						}
					}
	            return 1;
				}
			}
	        else if ( edgestate == 8){
	            if (y > 0){
	                if (x > 0){
	                    if (field[y-1][x-1] == '.'){
	                        return 0;
						}
					}
	                if (x < mazeW-1){
	                    if (field[y-1][x+1] == '.'){
	                        return 1;
						}
					}
				return 1;
				}
			}
			return 0;
		}
		else {
			var diags = new Array(1,2,4,8);
			if( arrayCount(diags,edgestate) ){
				return 1;
			}
			return 0;
		}
	}

	//make a cell at y,x a space
	function carve(posi) {
		var y = posi[0]; var x = posi[1];
		var extra = new Array();
		field[y][x] = '.' ; // this carves the space out
		if (x > 0){
			if (field[y][x-1] == '?') {
				field[y][x-1] = ',';
				extra.push(new Array(y,x-1));
			}
		}
		if (x < mazeW - 1){
			if (field[y][x+1] == '?') {
				field[y][x+1] = ',';
				extra.push(new Array(y,x+1));
			}
		}
		if (y>0){
			if (field[y-1][x] == '?') {
				field[y-1][x] = ',';
				extra.push(new Array(y-1,x));
			}
		}
		if (y < mazeH - 1){
			if (field[y+1][x] == '?') {
				field[y+1][x] = ',';
				extra.push(new Array(y+1,x));
			}
		}
		extra = shuffle(extra);
		frontier = frontier.concat(extra);
	}

	//make the cell at y,x a wall
	function harden(posi) {
		var y = posi[0]; var x = posi[1];
		field[y][x] = '#';
	}

	function shuffle(o){
		for(var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
		return o;
	}

	//draw a generated maze. Uses a field array and from drawMaze
	//ctx-canvas context. field - maze array. csize - size of each tile. ccolors - array defining what color to draw the tiles
	function drawMaze(ctx, field, csize, ccolors) {
		ctx.fillStyle = "rgb(35,35,5)";
		var cellsize = 8;
		if(csize){ cellsize = csize; }
		var cellcolors = "rgb(35,35,5)";
		if(ccolors){ cellcolors = ccolors; ctx.fillStyle = cellcolors; }
		for(var y=0; y<field.length; y+=1){
			var row = field[y];
			for(var x=0; x<row.length; x+=1){
				if(row[x] == '#'){
					//ctx.fillStyle = "rgb(35,35,5)";
					ctx.fillRect(x*cellsize,y*cellsize,cellsize,cellsize);
				}
				else if(row[x] == '.'){
					
				}
				else {
					//ctx.fillStyle = "rgb(117,209,96)";
					ctx.fillRect(x*cellsize,y*cellsize,cellsize,cellsize);
				}
			}	
		}
	}

</script>
</html>
<body>
	<canvas id="canvas" width="320" height="320"></canvas>
</body>