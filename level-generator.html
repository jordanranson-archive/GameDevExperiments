<!DOCTYPE html>
<head>
	<script>
		var grid = [];
		var width = 40;
		var branches = [];
		var ctx;
		var speed = 1;
		var deadZones = true;
		var process = true;
		var params = {
			capEnds: true,
			genNodes: true,
			deadZones: true,
			deadZoneChance: 0.05,
			deadZoneRange: {
				a: 0.45,
				b: 0.55
			}
		};

		function Branch( x, y, direction ) {
			this.x = x;
			this.y = y;
			this.direction = direction;
		};
		Branch.prototype = {
			pos: [],
			steps: 0,
			radius: 1,
			action: 'forward',
			lastAction: '',
			weights: [ 100, 100, 50 ],
			killCounter: 0,
			alive: true,
			aliveCounter: 0,

			swt: function( i ) { 
				return arguments[++i] 
			},

			update: function() {
				if( this.killCounter > 16 ) {
					this.alive = false;
				}

				// determine action
				if( this.steps <= 0 ) {

					// choose weights
					if( this.action === 'forward' && this.lastAction === 'forward' ) this.weights[0] = 50;
					else this.weights[0] = 100;

					if( this.aliveCounter < 2 ) this.weights[1] = 0;
					else if( this.action === 'turn' && this.lastAction === 'turn' ) this.weights[1] = 50;
					else this.weights[1] = 100;
					
					if( this.aliveCounter < 2 ) this.weights[2] = 0;
					else if( this.action === 'branch' && this.lastAction === 'branch' ) this.weights[2] = 50;
					else this.weights[2] = 100;

					// select action and number of steps
					this.action = this.swt( weightedRandom( 3, this.weights ), 'forward', 'turn', 'branch' );
					this.steps = 1;
				}

				// carry out action
				if( this.steps > 0 ) {

					// move forward
					if( this.action === 'forward' ) {
						var canMove;
						if( this.direction === 0 ) {
							canMove = check(this.x,this.y-1-this.radius);
							if( canMove ) this.y--;
						}
						if( this.direction === 1 ) {
							canMove = check(this.x+1+this.radius,this.y);
							if( canMove ) this.x++;
						}
						if( this.direction === 2 ) {
							canMove = check(this.x,this.y+1+this.radius);
							if( canMove ) this.y++;
						}
						if( this.direction === 3 ) {
							canMove = check(this.x-1-this.radius,this.y);
							if( canMove ) this.x--;
						}

						if( canMove ) {
							carve( this.x, this.y, this.radius );
							this.steps--;
						}
						else {
							this.steps = 0;
						}
					}

					// turn
					if( this.action === 'turn' ) {

						// TODO: favor certain directions

						// check if can turn in a direction
						var canTurn = false;
						var turnChance = Math.random()*3<<0;

						// check if can turn that direction
						if( this.direction === 0 || this.direction === 2 ) {
							if( turnChance === 0 ) {
								canTurn = check(this.x+1+this.radius,this.y);
								turnChance = 1;
							} 
							else if( turnChance === 1 ) { 
								canTurn = check(this.x-1-this.radius,this.y);
								turnChance = 3;
							}
							else {
								if( this.direction === 0 ) {
									canTurn = check(this.x,this.y+1+this.radius);
									turnChance = 2;
								}
							}
						}
						if( this.direction === 1 || this.direction === 3 ) {
							if( turnChance === 0 ) {
								canTurn = check(this.x,this.y+1+this.radius);
								turnChance = 2;
							} 
							else if( turnChance === 1 ) { 
								canTurn = check(this.x,this.y-1-this.radius);
								turnChance = 0;
							}
							else {
								if( this.direction === 3 ) {
									canTurn = check(this.x+1+this.radius,this.y);
									turnChance = 1;
								}
							}
						}

						// can do, turn!
						if( canTurn ) {
							this.direction = turnChance;

							this.action = 'forward';
							this.steps = this.radius+1;

							this.killCounter = 0;
						} else {
							this.killCounter++;
						}
					}

					// branch off
					if( this.action === 'branch' ) {
						var canBranch, pos = [];

						// choose random direction other than current direction and the direction just came from
						var d = this.direction;
						while( d === this.direction && d !== this.direction+2 && d !== this.direction-2 ) d = Math.round( Math.random()*3 );

						// check if space is available
						if( d === 0 ) {
							canBranch = check(this.x, this.y-1-this.radius);
						}
						if( d === 1 ) {
							canBranch = check(this.x+1+this.radius, this.y);
						}
						if( d === 2 ) {
							canBranch = check(this.x, this.y+1+this.radius);
						}
						if( d === 3 ) {
							canBranch = check(this.x-1-this.radius, this.y);
						}

						if( canBranch ) {
							branches.push( new Branch( this.x, this.y, d ) );
						}
						this.steps = 0;
					}
				}

				this.lastAction = this.action;
				this.aliveCounter++;
			}
		}

		window.onload = function() {
			var canvas = document.getElementById( 'canvas' );
			ctx = canvas.getContext( '2d' );

			var value = function( e ) { return Number(document.getElementById( e ).value); }
			var checked = function( e ) { return document.getElementById( e ).checked; }
			document.getElementById( 'btn_generate' ).onclick = function() {
				params.capEnds = checked( 'chk_capEnds' );
				params.genNodes = checked( 'chk_genNodes' );
				params.deadZones = checked( 'chk_deadZones' );
				params.deadZoneChance = value( 'txt_deadZoneChance' );
				params.deadZoneRange.a = value( 'txt_deadZoneRangeA' );
				params.deadZoneRange.b = value( 'txt_deadZoneRangeB' );
				console.log( params );

				generateLevel();
			};

			generateLevel();
		}

		function weightedRandom( choices, weight ) {
			var sum = 0;
			for(var i = 0; i < choices; i++ ) {
		   		sum += weight[i];
			}

			var rnd = Math.random()*sum;
			for( var i = 0; i < choices; i++ ) {
				if( rnd < weight[i] ) return i;
				rnd -= weight[i];
			}

			return false;
		}

		function processLevel() {
			var newGrid = [];
			for( var y = 0; y < grid.length; y++ ) {
				newGrid[y] = [];
			}

			// create networks
			var tile, n, e, s, w;
			for( var y = 0; y < grid.length; y++ ) {
				for( var x = 0; x < grid[y].length; x++ ) {
					tile = grid[y][x];
					n = grid[y-1] ? grid[y-1][x] : -1;
					e = grid[y][x+1] ? grid[y][x+1] : -1;
					s = grid[y+1] ? grid[y+1][x] : -1;
					w = grid[y][x-1] ? grid[y][x-1] : -1;

					nodeChance = 0;
					if( tile === 'X' ) {
							 if( n !== 'X' && e === 'X' && s !== 'X' && w === 'X' ) { newGrid[y][x] = '0'; } // h
						else if( n !== 'X' && e === 'X' && s !== 'X' && w !== 'X' ) { newGrid[y][x] = params.capEnds?'M':'0'; } // h - cap
						else if( n !== 'X' && e !== 'X' && s !== 'X' && w === 'X' ) { newGrid[y][x] = params.capEnds?'M':'0'; } // h - cap
						else if( n === 'X' && e !== 'X' && s === 'X' && w !== 'X' ) { newGrid[y][x] = '1'; } // v
						else if( n === 'X' && e !== 'X' && s !== 'X' && w !== 'X' ) { newGrid[y][x] = params.capEnds?'M':'1'; } // v - cap
						else if( n !== 'X' && e !== 'X' && s === 'X' && w !== 'X' ) { newGrid[y][x] = params.capEnds?'M':'1'; } // v - cap
						else if( n === 'X' && e === 'X' && s !== 'X' && w !== 'X' ) { newGrid[y][x] = '2'; } // ne
						else if( n === 'X' && e !== 'X' && s !== 'X' && w === 'X' ) { newGrid[y][x] = '3'; } // nw
						else if( n !== 'X' && e === 'X' && s === 'X' && w !== 'X' ) { newGrid[y][x] = '4'; } // se
						else if( n !== 'X' && e !== 'X' && s === 'X' && w === 'X' ) { newGrid[y][x] = '5'; } // sw
						else if( n === 'X' && e === 'X' && s !== 'X' && w === 'X' ) { newGrid[y][x] = '6'; } // hn
						else if( n !== 'X' && e === 'X' && s === 'X' && w === 'X' ) { newGrid[y][x] = '7'; } // hs
						else if( n === 'X' && e === 'X' && s === 'X' && w !== 'X' ) { newGrid[y][x] = '8'; } // ve
						else if( n === 'X' && e !== 'X' && s === 'X' && w === 'X' ) { newGrid[y][x] = '9'; } // vw
						else if( e === 'X' && w === 'X' && n === 'X' && s === 'X' ) { newGrid[y][x] = '10'; } // i
						else newGrid[y][x] = tile;
					}
					else {
						newGrid[y][x] = tile;
					}
				}
			}

			var nodeChance, makeNode, radius = 2;
			if( params.genNodes ) {
				for( var y = 0; y < grid.length; y++ ) {
					for( var x = 0; x < grid[y].length; x++ ) {
						tile = grid[y][x];
						n = grid[y-1] ? grid[y-1][x] : -1;
						e = grid[y][x+1] ? grid[y][x+1] : -1;
						s = grid[y+1] ? grid[y+1][x] : -1;
						w = grid[y][x-1] ? grid[y][x-1] : -1;

						nodeChance = 0;
						if( tile === 'X' ) {
								 if( n !== 'X' && e === 'X' && s !== 'X' && w === 'X' ) { nodeChance = 0.25; } // h
							else if( n === 'X' && e !== 'X' && s === 'X' && w !== 'X' ) { nodeChance = 0.25; } // v
							else if( n === 'X' && e === 'X' && s !== 'X' && w !== 'X' ) { nodeChance = 0.45; } // ne
							else if( n === 'X' && e !== 'X' && s !== 'X' && w === 'X' ) { nodeChance = 0.45; } // nw
							else if( n !== 'X' && e === 'X' && s === 'X' && w !== 'X' ) { nodeChance = 0.45; } // se
							else if( n !== 'X' && e !== 'X' && s === 'X' && w === 'X' ) { nodeChance = 0.45; } // sw
							else if( n === 'X' && e === 'X' && s !== 'X' && w === 'X' ) { nodeChance = 0.65; } // hn
							else if( n !== 'X' && e === 'X' && s === 'X' && w === 'X' ) { nodeChance = 0.65; } // hs
							else if( n === 'X' && e === 'X' && s === 'X' && w !== 'X' ) { nodeChance = 0.65; } // ve
							else if( n === 'X' && e !== 'X' && s === 'X' && w === 'X' ) { nodeChance = 0.65; } // vw
							else if( e === 'X' && w === 'X' && n === 'X' && s === 'X' ) { nodeChance = 0.85; } // i

							if( Math.random() >= 1-nodeChance ) {

								// look for surrounding nodes
								makeNode = true;
								radius = (Math.random()*4<<0) + 1;
								for( var j = -radius; j <= radius; j++ ) {
									for( var k = -radius; k <= radius; k++ ) {
										if( newGrid[y+j] && newGrid[y+j][x+k] && newGrid[y+j][x+k] === 'N' ) makeNode = false;
										if( newGrid[y+j] && newGrid[y+j][x+k] && newGrid[y+j][x+k] === 'M' ) makeNode = false;
									}
								}
								
								// do it
								if( makeNode ) {
									newGrid[y][x] = 'N';
									lastNode = 0;
								}
							}
						}
					}
				}
			}

			grid = newGrid;
		}

		function generateLevel() {
			grid = [];
			branches.length = 0;
			process = true;

			/* 
				? - unexplored 
				. - explored

				0 - horz
				1 - vert
				2 - ne
				3 - nw
				4 - se
				5 - sw
				6 - horz n
				7 - horz s
				8 - vert e
				9 - vert w
				10 - intersection

				N - empty node
			*/

			for( var y = 0; y < width; y++ ) { 
				grid[y] = [];
			}
			for( var y = 0; y < width; y++ ) {
				for( var x = 0; x < width; x++ ) {
					if( 
						params.deadZones &&
						Math.random() < params.deadZoneChance && 
						y > 2 && 
						x > 2 && 
						(y < width*params.deadZoneRange.a || y > width*params.deadZoneRange.b) && 
						(x < width*params.deadZoneRange.a || x > width*params.deadZoneRange.b) && 
						y < width-3 && 
						x < width-3 
					) {
						grid[y][x] = '.';
						grid[y+1][x+1] = '.';
						grid[y-1][x-1] = '.';
						grid[y+1][x-1] = '.';
						grid[y-1][x+1] = '.';
					} 
					else if( grid[y][x] !== '.' ) {
						grid[y][x] = '?';
					}
				}
			}

			var sx = Math.round( Math.random() * (width*0.15) ) + Math.round( (width*0.05) );
			var sy = Math.round( Math.random() * (width*0.15) ) + Math.round( (width*0.05) );
			sx = sy = Math.round( width*0.5 );
			carve( sx, sy, 1 );
			branches.push( new Branch( sx, sy, 0 ) );

			var branch;
			var timer = setInterval( function() {
				for( var k = 0; k < branches.length; k++ ) {
					branch = branches[k];
					branch.update();

					// remove from array if dead
					if( !branch.alive ) {
						branches.splice( branches.indexOf(branch), 1 );
					}
				}

				if( branches.length <= 0 && process ) {
					process = false;
					processLevel();
					clearInterval( timer );
				}
				drawLevel( ctx );
			}, speed );
		}

		function check( x, y ) {
			if( x < 0 ) return false;
			if( y < 0 ) return false;
			if( x > width ) return false;
			if( y > width ) return false;

			if( grid[y] && grid[y][x] && grid[y][x] === '?' ) return true;

			return false;
		}

		function carve( x, y, radius, value ) {
			value = value ? value : 'X';
			for( var j = -radius; j <= radius; j++ ) {
				for( var k = -radius; k <= radius; k++ ) {
					if( check(x+k,y+j) ) grid[y+j][x+k] = '.';
				}
			}
			grid[y][x] = value;
		}

		function drawLevel( context ) {
			context.fillStyle = '#000';
			context.fillRect( 0, 0, 640, 640 );

			var tile;
			for( var y = 0; y < grid.length; y++ ) {
				for( var x = 0; x < grid[y].length; x++ ) {
					tile = grid[y][x];

					// draw explored area
					if( tile !== '?' ) {
						context.fillStyle = '#12171c';
						context.fillRect( x*16, y*16, 15, 15 );
					}

					// draw network
					context.fillStyle = '#525c6b';
					if( tile === 'X' ) {
						context.fillRect( x*16, y*16, 15, 15 );
					}
					if( tile === '0' ) {
						context.fillRect( x*16, y*16+5, 15, 5 );
					}
					if( tile === '1' ) {
						context.fillRect( x*16+5, y*16, 5, 15 );
					}
					if( tile === '2' ) {
						context.fillRect( x*16+5, y*16+5, 10, 5 );
						context.fillRect( x*16+5, y*16, 5, 10 );
					}
					if( tile === '3' ) {
						context.fillRect( x*16, y*16+5, 10, 5 );
						context.fillRect( x*16+5, y*16, 5, 10 );
					}
					if( tile === '4' ) {
						context.fillRect( x*16+5, y*16+5, 10, 5 );
						context.fillRect( x*16+5, y*16+5, 5, 10 );
					}
					if( tile === '5' ) {
						context.fillRect( x*16, y*16+5, 10, 5 );
						context.fillRect( x*16+5, y*16+5, 5, 10 );
					}
					if( tile === '6' ) {
						context.fillRect( x*16, y*16+5, 15, 5 );
						context.fillRect( x*16+5, y*16, 5, 10 );
					}
					if( tile === '7' ) {
						context.fillRect( x*16, y*16+5, 15, 5 );
						context.fillRect( x*16+5, y*16+5, 5, 10 );
					}
					if( tile === '8' ) {
						context.fillRect( x*16+5, y*16+5, 10, 5 );
						context.fillRect( x*16+5, y*16, 5, 15 );
					}
					if( tile === '9' ) {
						context.fillRect( x*16, y*16+5, 10, 5 );
						context.fillRect( x*16+5, y*16, 5, 15 );
					}
					if( tile === '10' ) {
						context.fillRect( x*16, y*16+5, 15, 5 );
						context.fillRect( x*16+5, y*16, 5, 15 );
					}

					// draw nodes
					if( tile === 'N' ) {
						context.fillStyle = '#0ff';
						context.fillRect( x*16, y*16, 15, 15 );
					}
					if( tile === 'M' ) {
						context.fillStyle = '#ff0';
						context.fillRect( x*16, y*16, 15, 15 );
					}

				}
			}
		}
	</script>
	<style>
		body { 
			padding: 0; 
			margin: 0; 
			background: #12171c; 
			color: #dae1ec;
			font: 12pt/1.2em sans-serif;
		}
		.wrapper {
			width: 1200px;
			height: 800px;
			position: absolute;
			top: 0;
			right: 0;
			bottom: 0;
			left: 0;
			margin: auto;
			overflow: hidden;
		}
		.canvas {
			float: left;
			background: #000;
			padding: 16px;
		}
		.controls {
			float: left;
			background: #242e3b;
			margin: 0 0 0 16px;
			padding: 16px;
		}
		input.small {
			width: 40px;
			text-align: center;
		}
	</style>
</head>
<body>
	<div class="wrapper">
		<h1>Node Controller Level Generator</h1>
			<div class="canvas">
				<canvas id="canvas" width="640" height="640"></canvas>
			</div>
			<div class="controls">
				<form>
					<h3>Generation Settings</h3>

					<h3>Dead Zone Settings</h3>
					<p><input type="checkbox" id="chk_deadZones" checked /> <label for="chk_deadZones">Generate dead zones</label></p>
					<p><input type="text" id="txt_deadZoneChance" class="small" value="0.05" /> <label for="txt_deadZoneChance">Dead zone chance</label> </p>
					<p>
						<input type="text" id="txt_deadZoneRangeA" class="small" value="0.45" />
						<input type="text" id="txt_deadZoneRangeB" class="small" value="0.55" />
						<label for="txt_deadZoneRangeA">Dead zone range</label> 
					</p>

					<h3>Network generation</h3>
					<p><input type="checkbox" id="chk_capEnds" checked /> <label for="chk_capEnds">Cap ends with nodes</label></p>

					<h3>Node generation</h3>
					<p><input type="checkbox" id="chk_genNodes" checked /> <label for="chk_genNodes">Generate nodes</label></p>

					<br />
					<p><input type="button" id="btn_generate" value="Generate"/></p>
				</form>
			</div>
	</div>
</body>